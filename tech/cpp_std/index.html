<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>C++ STL - Hank Tech Lab</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Binary Search int version while (L < R) { int M = L + (R-L)/2; if (check(M)) { return M; } else if (A[M] < target) { L = M+1; } else { R = M; } } return L; double version while (R - L > 1e-6) { double M = L + (R-L) / 2.0; if (M < target) { L = M; } else { R = M; } } return L; L X X X M X T X R"><meta property="og:image" content><meta property="og:url" content="https://hanketgithub.github.io/tech/cpp_std/"><meta property="og:site_name" content="Hank Tech Lab"><meta property="og:title" content="C++ STL"><meta property="og:description" content="Binary Search int version while (L < R) { int M = L + (R-L)/2; if (check(M)) { return M; } else if (A[M] < target) { L = M+1; } else { R = M; } } return L; double version while (R - L > 1e-6) { double M = L + (R-L) / 2.0; if (M < target) { L = M; } else { R = M; } } return L; L X X X M X T X R"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="tech"><meta property="article:published_time" content="2025-04-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-10T00:00:00+00:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ STL"><meta name=twitter:description content="Binary Search int version while (L < R) { int M = L + (R-L)/2; if (check(M)) { return M; } else if (A[M] < target) { L = M+1; } else { R = M; } } return L; double version while (R - L > 1e-6) { double M = L + (R-L) / 2.0; if (M < target) { L = M; } else { R = M; } } return L; L X X X M X T X R"><link href=https://hanketgithub.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://hanketgithub.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://hanketgithub.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css disabled><style>@media print{body{font-family:pingfang tc,helvetica neue,sans-serif;font-size:12pt;line-height:1.6;color:#000}table,th,td{border:1px solid #666;border-collapse:collapse}th,td{padding:8px 12px;text-align:left}h1,h2{page-break-before:always}h1:first-of-type,h2:first-of-type{page-break-before:auto}img{max-width:100%;height:auto;page-break-inside:avoid}p{page-break-inside:avoid}a{color:#000;text-decoration:none}}</style></head><body><div class=content><header><div class=main><a href=https://hanketgithub.github.io/>Hank Tech Lab</a></div><nav><a href=/posts/>Posts</a>
| <span id=dark-mode-toggle onclick=toggleTheme()><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#sun"/></svg></span>
<script src=https://hanketgithub.github.io/js/themetoggle.js></script></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>C++ STL</h1><div class=meta>Posted on Apr 10, 2025</div></div><section class=body><h2 id=binary-search>Binary Search</h2><h3 id=int-version>int version</h3><pre tabindex=0><code>while (L &lt; R) {
  int M = L + (R-L)/2;
  if (check(M)) { return M; }
  else if (A[M] &lt; target) { L = M+1; }
  else { R = M; }
}
return L;
</code></pre><h3 id=double-version>double version</h3><pre tabindex=0><code>while (R - L &gt; 1e-6) {
  double M = L + (R-L) / 2.0;
  if (M &lt; target) { L = M; }
  else { R = M; }
}
return L;
</code></pre><p>L X X X M X T X R</p><h2 id=vector>Vector</h2><h3 id=declaration>Declaration:</h3><pre tabindex=0><code>vector&lt;int&gt; vec;
</code></pre><h3 id=2d>2D:</h3><pre tabindex=0><code>vector&lt; vector&lt;int&gt; &gt; vec(n, vector&lt;int&gt;(m, 0));
</code></pre><h3 id=size>Size:</h3><pre tabindex=0><code>vec.size()
</code></pre><h3 id=add>Add:</h3><pre tabindex=0><code>vec.push_back(v)
</code></pre><h3 id=remove>Remove:</h3><pre tabindex=0><code>vec.erase( vec.begin() ); // remove head
vec.erase( vec.begin()+2 ); // remove idx=2, the 3rd element
</code></pre><h3 id=read>Read:</h3><pre tabindex=0><code>int v = vec.at(i);
int v = vec[i];
</code></pre><h3 id=overwrite>Overwrite:</h3><pre tabindex=0><code>vec[i] = newVal;
</code></pre><h3 id=sort>Sort:</h3><pre tabindex=0><code>sort(vec.begin(), vec.end()); // from small to large
sort(vec.begin(), ven.end(), greater&lt;int&gt;()); // from large to small
</code></pre><h3 id=custom-sort>Custom Sort:</h3><pre tabindex=0><code>struct Interval {
  int start;
  int end;
};

bool compar(T a, T b) { // return true if &#39;a&#39; should be placed before &#39;b&#39;
  if (a.start == b.start) { return a.end &lt; b.end; }
  else { return a.start &lt; b.start; }
}
sort(vec.begin(), vec.end(), compar);
</code></pre><h3 id=trick-use-two-elements-enumeration-to-check-if-compar-is-what-you-want>Trick: Use Two elements enumeration to check if compar() is what you want.</h3><pre tabindex=0><code>vector&lt;struct Interval&gt; A = { {1, 5}, {1, 3} };
sort(A.begin(), A.end(), compar);
</code></pre><h3 id=searchsorted>Search(sorted):</h3><pre tabindex=0><code>1 3 5 7 9
  ^
auto it = lower_bound(vec.begin(), vec.end(), 3); // first element greater or equal to 3


1 3 5 7 9
    ^
auto it = upper_bound(vec.begin(), vec.end(), 3); // first element greater than 3, which is 5


8 7 5 5 4 3 3 2 1
          ^
auto it = lower_bound(vec.begin(), vec.end(), 3, greater&lt;int&gt;());
// first element smaller or equal to 3.

8 7 5 5 4 3 3 2 1
        ^
auto it = upper_bound(vec.begin(), vec.end(), 5, greater&lt;int&gt;());
// first element smaller than 5
</code></pre><h2 id=setsorted>Set(sorted)</h2><h3 id=declaration-1>Declaration:</h3><pre tabindex=0><code>set&lt;int&gt; s;
set&lt;int, greater&lt;int&gt;&gt; s; // decreasing
</code></pre><h3 id=size-1>Size:</h3><pre tabindex=0><code>s.size();
</code></pre><h3 id=add-1>Add:</h3><pre tabindex=0><code>s.insert(v);
</code></pre><h3 id=remove-1>Remove:</h3><pre tabindex=0><code>s.erase(v);
</code></pre><h3 id=check-exist>Check exist:</h3><pre tabindex=0><code>s.find(v) != s.end() // faster
s.count(v);
</code></pre><h3 id=foreach>Foreach:</h3><pre tabindex=0><code>for (auto v : s) { ... }
</code></pre><h3 id=iterator>Iterator:</h3><pre tabindex=0><code>I: set&lt;int&gt;::iterator iter = s.begin(); // point to beginning
II: iter = s.end(); // point to end
III: set&lt;int&gt;::iterator nx = next(iter, 1); // point to iter&#39;s next
</code></pre><h3 id=for-loop>For Loop:</h3><pre tabindex=0><code>// from small to big
for (set&lt;int&gt;::iterator iter = s.begin(); iter != s.end(); iter++) {
  int v = *iter;
}
// from big to small
for (set&lt;int&gt;::reverse_iterator iter = s.rbegin(); iter != s.rend(); iter++) {
  int v = *iter;
}
</code></pre><h3 id=remove-duplicates>Remove duplicates:</h3><pre tabindex=0><code>vector&lt;int&gt; vec = { 1,1,2,2,2,3 };
set&lt;int&gt; s(vec.begin(), vec.end()); // s has 1,2,3
</code></pre><h2 id=setunsorted>Set(Unsorted)</h2><h3 id=declaration-2>Declaration:</h3><pre tabindex=0><code>unordered_set set&lt;int&gt; s;
</code></pre><h3 id=size-2>Size:</h3><pre tabindex=0><code>s.size();
</code></pre><h3 id=add-2>Add:</h3><pre tabindex=0><code>s.insert(v);
</code></pre><h3 id=remove-2>Remove:</h3><pre tabindex=0><code>s.erase(v);
</code></pre><h3 id=find>Find:</h3><pre tabindex=0><code>s.count(v);
I: exists -&gt; return 1
II: not exist -&gt; return 0
</code></pre><h3 id=foreach-1>Foreach:</h3><pre tabindex=0><code>for (auto v : s) { ... }
</code></pre><h3 id=remark-no-iterator-style>Remark: No iterator style</h3><h2 id=multiset>multiset</h2><p>Be careful about &rsquo;erase&rsquo; element!</p><pre tabindex=0><code>multiset&lt;int&gt; ms = { 2,3,3,5 };

ms.erase(3); // only {2,5}
ms.erase(ms.find(3)) // {2,3,5}
</code></pre><h2 id=mapsorted>Map(Sorted)</h2><h3 id=declaration-3>Declaration:</h3><pre tabindex=0><code>map&lt;int, int&gt; mp;
</code></pre><h3 id=add-3>Add:</h3><pre tabindex=0><code>mp.insert( { key, val } ); // make a pair and insert
mp[key] = val;
</code></pre><h3 id=remove-3>Remove:</h3><pre tabindex=0><code>mp.erase(key);
mp.erase(first, last); // remove all b/t first and last
</code></pre><h3 id=check-if-key-exists>Check if {key} exists:</h3><pre tabindex=0><code>mp.find(key);
- Exists: mp.find(key) != mp.end()
- Not exist: mp.find(key) == mp.end();
</code></pre><h3 id=foreach-2>Foreach:</h3><pre tabindex=0><code>for (auto iter : mp) {
  int key = iter.first;
  int val = iter.second;
}

for (auto &amp;[k, v] : mp) {
  // k is key, v is value
}
</code></pre><h3 id=-binary-search>*** Binary Search</h3><pre tabindex=0><code>// mp[start] = end, represent a segment
mp[1] = 5;
mp[6] = 8;
mp[9] = 12;

T = 7

auto it = mp.upper_bound(T); // points to mp[9]
it = prev(it); // it points to mp[6]
</code></pre><h2 id=mapunsorted>Map(Unsorted)</h2><h3 id=declaration-4>Declaration:</h3><pre tabindex=0><code>unordered_map&lt;int, int&gt; mp;
</code></pre><h3 id=add-4>Add:</h3><pre tabindex=0><code>mp.insert( { key, val } ); // make a pair and insert
mp[key] = val;
</code></pre><h3 id=remove-4>Remove:</h3><pre tabindex=0><code>mp.erase(key);
</code></pre><h3 id=check-if-key-value-exists>Check if {key, value} exists:</h3><pre tabindex=0><code>mp.find(key);
- Exists: mp.find(key) != mp.end()
- Not exist: mp.find(key) == mp.end();
</code></pre><h3 id=check-key>Check Key:</h3><pre tabindex=0><code>mp.count(key);
</code></pre><h3 id=for-loop-1>For Loop:</h3><pre tabindex=0><code>for (unordered_map&lt;int, int&gt;::iterator iter = mp.begin(); iter != mp.end(); iter++) {
  int key = iter-&gt;first;
  int val = iter-&gt;second;
}
</code></pre><h3 id=foreach-3>Foreach:</h3><pre tabindex=0><code>for (auto iter : mp) {
  int key = iter.first;
  int val = iter.second;
}

for (auto &amp;[k, v] : mp) {
  // k is key, v is value
}
</code></pre><h2 id=priority-queue>Priority Queue</h2><pre tabindex=0><code>// Max Heap
priority_queue&lt;int&gt; mx;
priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; mx;

// Min Heap
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; mi;
mi.push(5);
mi.push(1);
mi.push(3);
mi.top(); -&gt; 1
mi.pop();
mi.top(); -&gt; 3
mi.pop();
mi.top(); -&gt; 5
</code></pre><p>Custom comparator:</p><ul><li>The comparator answers the question: Is &lsquo;a&rsquo; of lower priority than &lsquo;b&rsquo;?</li><li>true: &lsquo;b&rsquo; has higher priority.</li><li>This reverses the usual intuition: to give a higher priority, we need to return false when &lsquo;a&rsquo; is “larger.”</li></ul><p>sort {l, r} such that larger r than smaller l</p><pre tabindex=0><code>auto compar = [](const PII &amp;a, const PII &amp;b) {
  if (a.second != b.second) { a.second &lt; b.second; }
  else { a.first &gt; b.first; }
};
</code></pre><h2 id=dijkstra>Dijkstra</h2><pre tabindex=0><code>priority_queue&lt; PII, vector&lt; PII &gt;, greater&lt;&gt; &gt; pq;

pq.push( { 5, 1 } ); // weight 5, dst node 1
pq.push( { 3, 2 } ); // weight 3, dst node 2
pq.push( { 3, 5 } ); // weight 3, dst node 5

auto [w, dst] = pq.top() -&gt; w is 3, dst is 2
pq.pop();
auto [w, dst] = pq.top() -&gt; w is 3, dst is 5
pq.pop();
auto [w, dst] = pq.top() -&gt; w is 5, dst is 1
pq.pop();
</code></pre><p>Sample implements;</p><pre tabindex=0><code>vector&lt;int&gt; dist(n, INT_MAX/2);

int PFS(vector&lt; vector&lt;int&gt; &gt; &amp;gf, int src, int dst, vector&lt;int&gt; &amp;dist) {
  auto compar = [](const PII &amp;a, const PII &amp;b) { // return true if &#39;a&#39; has lower priority
    if (a.first != b.first) {
      return !(a.first &lt; b.first);
    }
    else {
      return !(a.second &lt; b.second);
    }
  };
  priority_queue&lt;PII, vector&lt;PII&gt;, decltype(compar)&gt; pq; // { distance, next }
  pq.push( {0, 0} );

  while (!pq.empty()) {
    auto [distance, cur] = pq.top(); pq.pop();

    if (dist[cur] != INT_MAX/2) { continue; } // visited
    dist[cur] = distance;

    if (cur == dst) { return distance; }

    for (auto nxt : gf[cur]) {
      pq.push( { distance+1, nxt } );
    }
  }

  return -1;
}
</code></pre><h2 id=union-find>Union Find</h2><pre tabindex=0><code>int FindRoot(int v, vector&lt;int&gt; &amp;root) {
  if (root[v] != v) {
    root[v] = FindRoot(root[v], root); // Path compression
  }
  return root[v];
}

void Union(int p, int q, vector&lt;int&gt; &amp;root) {
  int rp = FindRoot(p, root);
  int rq = FindRoot(q, root);

  if (rp != rq) {
    if (rp &lt; rq) {
      root[rq] = rp;
    }
    else {
      root[rp] = rq;
    }
  }
}

vector&lt;int&gt; root(n);

for (int i = 0; i &lt; n; i++) { root[i] = i; }
</code></pre><h2 id=queue>Queue</h2><p>Declaration:</p><pre tabindex=0><code>queue&lt;int&gt; q;
</code></pre><p>Add:</p><pre tabindex=0><code>q.push(v);
</code></pre><p>Remove:</p><pre tabindex=0><code>q.pop();
</code></pre><p>Peek:</p><pre tabindex=0><code>int v = q.front();
</code></pre><p>Emptiness:</p><pre tabindex=0><code>bool isEmpty = q.empty();
</code></pre><h2 id=deque>Deque</h2><p>Declaration:</p><pre tabindex=0><code>deque&lt;int&gt; deq;
</code></pre><p>Add:</p><pre tabindex=0><code>deq.push_front(v);
deq.push_back(v);
</code></pre><p>Remove:</p><pre tabindex=0><code>deq.pop_front();
deq.pop_back();
</code></pre><p>Peek:</p><pre tabindex=0><code>int first = deq.front();
int last = deq.back();
</code></pre><h2 id=stack>Stack</h2><p>Declaration:</p><pre tabindex=0><code>stack&lt;int&gt; st;
</code></pre><p>Add:</p><pre tabindex=0><code>st.push(v);
</code></pre><p>Remove:</p><pre tabindex=0><code>st.pop();
</code></pre><p>Peek:</p><pre tabindex=0><code>st.top();
</code></pre><h2 id=convert-integer-to-string>Convert integer to string:</h2><pre tabindex=0><code>int a = 135;
string s = to_string(a);
</code></pre><h2 id=trie>Trie</h2><pre tabindex=0><code>#define WIDTH 256


class TrieNode {
public:
  TrieNode *next[WIDTH];
  bool isWord;

  TrieNode() {
    memset(next, 0, sizeof(next));
    isWord = false;
  }

  ~TrieNode() {
    for (int i = 0; i &lt; WIDTH; i++) {
      if (next[i]) { delete next[i]; }
    }
  }
};

class Trie {
  TrieNode *root;

public:
  Trie() {
    root = new TrieNode();
  }

  /** Inserts a word into the Trie. Update count */
  void insert(string &amp;s) {
    TrieNode *p = root;
    for (auto c : s) {
      if (!p-&gt;next[c]) {
        p-&gt;next[c] = new TrieNode();
      }
      p = p-&gt;next[c];
    }
    p-&gt;isWord = true;
  }

  /** Returns count for s in the Trie. */
  bool search(string &amp;s) {
    TrieNode *p = root;
    for (int i = 0; i &lt; s.size() &amp;&amp; p; i++) {
      p = p-&gt;next[ s[i] ];
    }
    return p &amp;&amp; p-&gt;isWord;
  }

  bool startWith(string &amp;prefix) {
    TrieNode *p = root;
    for (int i = 0; i &lt; prefix.size() &amp;&amp; p; i++) {
      p = p-&gt;next[ prefix[i] ];
    }
    return p;
  }

  ~Trie() {
    delete root;
  }
};
</code></pre><h2 id=misc>Misc</h2><p>lambda function - an embedded function without name</p><pre tabindex=0><code>vector&lt;int&gt; A;

// Now sort from large to small
bool compar(int a, int b) { return a &gt; b; }
sort(A.begin(), A.end(), compar);

// lambda
sort(A.begin(), A.end(), [](int a, int b) { return a &gt; b; })


// lamba used in callback
void cb(int n) { cout &lt;&lt; n &lt;&lt; endl; }

thread t(cb, n);


thread t([](int n) { cout &lt;&lt; n &lt;&lt; endl; }, n);
</code></pre><p>Unique Pointer</p><pre tabindex=0><code>unique_ptr&lt;MyClass&gt; p = make_unique&lt;MyClass&gt;();
</code></pre><p>Shared Pointer</p><pre tabindex=0><code>shared_ptr&lt;MyClass&gt; p = make_shared&lt;MyClass&gt;();
</code></pre><p>Member Initializer List -</p><pre tabindex=0><code>struct X {
  int c;
  int d;
};

class T {
  int a;
  int b;
  struct X x;

  T() : a(-1), b(0), x{3, 4} {
  }
}
</code></pre><p>Overflow, MOD
Safe:</p><pre tabindex=0><code>+: (a + b) % MOD -&gt; ( (a % MOD) + (b % MOD) ) % MOD
*: (a * b) % MOD -&gt; ( (a % MOD) * (b % MOD) ) % MOD
</code></pre><p>Need process:</p><pre tabindex=0><code>-: (a - b) % MOD -&gt; (a - b + MOD) % MOD)
</code></pre><p>Meanless:</p><pre tabindex=0><code>/: (a / b) % MOD is not ( (a % MOD) / (b % MOD) ). But (a / b) is not going to overflow.
</code></pre><p>Prime:</p><pre tabindex=0><code>vector&lt;bool&gt; isPrime(limit+5, true);

void PrimeSieve(vector&lt;bool&gt; &amp;isPrime, int limit) {
  isPrime[0] = false;
  isPrime[1] = false;

  for (int p = 2; p &lt;= sqrt(limit); p++) {
    if (isPrime[p]) {
      for (int x = p * p; x &lt;= limit; x += p) {
        isPrime[x] = false;
      }
    }
  }
}
</code></pre></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/c++>c++</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex></div><div class=footer-info>2025 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>