<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>VCU 開發進度總結 — 2025-08-01 - Hank Tech Lab</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="更新概要（2025-07-30） 已確認 Allegro encoder callback 機制會卡住是因為未在 callback 中呼叫 AL_Encoder_PutStreamBuffer() 歸還使用過的 bitstream buffer。此行為違反一般 callback 使用常識，但確實為必要操作，否則 encoder 將無法繼續產出 ES。
Send Input Frame Trace（2025-08-01） exe_encoder 主邏輯在 SafeChannelMain() 裡：
while (...) { LayerResources::SendInput(...); } 🔁 Function Call Trace SafeChannelMain() └─ LayerResources::SendInput(cfg, enc.get(), traceHooker) └─ sendInputFileTo( frameReader, SrcBufPool, SrcYuv.get(), cfg, FileInfo, pSrcConv.get(), firstSink, iPictCount, iReadCount ) └─ GetSrcFrame( iReadCount, iPictCount, frameReader, FileInfo, SrcBufPool, Yuv, tChParam, cfg, pSrcConv ) └─ ReadSourceFrame(SrcBufPool, Yuv, frameReader, tUpdatedDim, pSrcConv) └─ ReadSourceFrameBuffer(pBuffer, conversionBuffer, frameReader, tUpdatedDim, pSrcConv) ├─ if conversion needed: │ ├─ frameReader->ReadFrame(conversionBuffer) │ └─ pSrcConv->ConvertSrcBuf(conversionBuffer, pBuffer) └─ else: └─ frameReader->ReadFrame(pBuffer) 🧩 Input Components 說明 變數名 類型 / 來源 備註 frameReader unique_ptr<FrameReader> Instance variable（UnCompFrameReader） SrcBufPool PixMapBufPool DMA allocator buffer pool Yuv AL_TBuffer * 使用 SrcYuv."><meta property="og:image" content><meta property="og:url" content="https://hanketgithub.github.io/tech/vcu_progress/"><meta property="og:site_name" content="Hank Tech Lab"><meta property="og:title" content="VCU 開發進度總結 — 2025-08-01"><meta property="og:description" content="更新概要（2025-07-30） 已確認 Allegro encoder callback 機制會卡住是因為未在 callback 中呼叫 AL_Encoder_PutStreamBuffer() 歸還使用過的 bitstream buffer。此行為違反一般 callback 使用常識，但確實為必要操作，否則 encoder 將無法繼續產出 ES。
Send Input Frame Trace（2025-08-01） exe_encoder 主邏輯在 SafeChannelMain() 裡：
while (...) { LayerResources::SendInput(...); } 🔁 Function Call Trace SafeChannelMain() └─ LayerResources::SendInput(cfg, enc.get(), traceHooker) └─ sendInputFileTo( frameReader, SrcBufPool, SrcYuv.get(), cfg, FileInfo, pSrcConv.get(), firstSink, iPictCount, iReadCount ) └─ GetSrcFrame( iReadCount, iPictCount, frameReader, FileInfo, SrcBufPool, Yuv, tChParam, cfg, pSrcConv ) └─ ReadSourceFrame(SrcBufPool, Yuv, frameReader, tUpdatedDim, pSrcConv) └─ ReadSourceFrameBuffer(pBuffer, conversionBuffer, frameReader, tUpdatedDim, pSrcConv) ├─ if conversion needed: │ ├─ frameReader->ReadFrame(conversionBuffer) │ └─ pSrcConv->ConvertSrcBuf(conversionBuffer, pBuffer) └─ else: └─ frameReader->ReadFrame(pBuffer) 🧩 Input Components 說明 變數名 類型 / 來源 備註 frameReader unique_ptr<FrameReader> Instance variable（UnCompFrameReader） SrcBufPool PixMapBufPool DMA allocator buffer pool Yuv AL_TBuffer * 使用 SrcYuv."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="tech"><meta property="article:published_time" content="2025-07-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-01T00:00:00+00:00"><meta property="article:tag" content="VCU"><meta name=twitter:card content="summary"><meta name=twitter:title content="VCU 開發進度總結 — 2025-08-01"><meta name=twitter:description content="更新概要（2025-07-30） 已確認 Allegro encoder callback 機制會卡住是因為未在 callback 中呼叫 AL_Encoder_PutStreamBuffer() 歸還使用過的 bitstream buffer。此行為違反一般 callback 使用常識，但確實為必要操作，否則 encoder 將無法繼續產出 ES。
Send Input Frame Trace（2025-08-01） exe_encoder 主邏輯在 SafeChannelMain() 裡：
while (...) { LayerResources::SendInput(...); } 🔁 Function Call Trace SafeChannelMain() └─ LayerResources::SendInput(cfg, enc.get(), traceHooker) └─ sendInputFileTo( frameReader, SrcBufPool, SrcYuv.get(), cfg, FileInfo, pSrcConv.get(), firstSink, iPictCount, iReadCount ) └─ GetSrcFrame( iReadCount, iPictCount, frameReader, FileInfo, SrcBufPool, Yuv, tChParam, cfg, pSrcConv ) └─ ReadSourceFrame(SrcBufPool, Yuv, frameReader, tUpdatedDim, pSrcConv) └─ ReadSourceFrameBuffer(pBuffer, conversionBuffer, frameReader, tUpdatedDim, pSrcConv) ├─ if conversion needed: │ ├─ frameReader->ReadFrame(conversionBuffer) │ └─ pSrcConv->ConvertSrcBuf(conversionBuffer, pBuffer) └─ else: └─ frameReader->ReadFrame(pBuffer) 🧩 Input Components 說明 變數名 類型 / 來源 備註 frameReader unique_ptr<FrameReader> Instance variable（UnCompFrameReader） SrcBufPool PixMapBufPool DMA allocator buffer pool Yuv AL_TBuffer * 使用 SrcYuv."><link href=https://hanketgithub.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://hanketgithub.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://hanketgithub.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css disabled><style>@media print{body{font-family:pingfang tc,helvetica neue,sans-serif;font-size:12pt;line-height:1.6;color:#000}table,th,td{border:1px solid #666;border-collapse:collapse}th,td{padding:8px 12px;text-align:left}h1,h2{page-break-before:always}h1:first-of-type,h2:first-of-type{page-break-before:auto}img{max-width:100%;height:auto;page-break-inside:avoid}p{page-break-inside:avoid}a{color:#000;text-decoration:none}}</style></head><body><div class=content><header><div class=main><a href=https://hanketgithub.github.io/>Hank Tech Lab</a></div><nav><a href=/posts/>Posts</a>
| <span id=dark-mode-toggle onclick=toggleTheme()><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#sun"/></svg></span>
<script src=https://hanketgithub.github.io/js/themetoggle.js></script></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>VCU 開發進度總結 — 2025-08-01</h1><div class=meta>Posted on Jul 1, 2025</div></div><section class=body><h2 id=更新概要2025-07-30>更新概要（2025-07-30）</h2><p>已確認 Allegro encoder callback 機制會卡住是因為未在 callback 中呼叫 <code>AL_Encoder_PutStreamBuffer()</code> 歸還使用過的 bitstream buffer。此行為違反一般 callback 使用常識，但確實為必要操作，否則 encoder 將無法繼續產出 ES。</p><hr><h2 id=send-input-frame-trace2025-08-01>Send Input Frame Trace（2025-08-01）</h2><p><code>exe_encoder</code> 主邏輯在 <code>SafeChannelMain()</code> 裡：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>while</span> (...) {
</span></span><span style=display:flex><span>  LayerResources<span style=color:#f92672>::</span>SendInput(...);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=-function-call-trace>🔁 Function Call Trace</h3><pre tabindex=0><code>SafeChannelMain()
└─ LayerResources::SendInput(cfg, enc.get(), traceHooker)
   └─ sendInputFileTo(
        frameReader,
        SrcBufPool,
        SrcYuv.get(),
        cfg,
        FileInfo,
        pSrcConv.get(),
        firstSink,
        iPictCount,
        iReadCount
      )
      └─ GetSrcFrame(
           iReadCount,
           iPictCount,
           frameReader,
           FileInfo,
           SrcBufPool,
           Yuv,
           tChParam,
           cfg,
           pSrcConv
         )
         └─ ReadSourceFrame(SrcBufPool, Yuv, frameReader, tUpdatedDim, pSrcConv)
            └─ ReadSourceFrameBuffer(pBuffer, conversionBuffer, frameReader, tUpdatedDim, pSrcConv)
               ├─ if conversion needed:
               │    ├─ frameReader-&gt;ReadFrame(conversionBuffer)
               │    └─ pSrcConv-&gt;ConvertSrcBuf(conversionBuffer, pBuffer)
               └─ else:
                    └─ frameReader-&gt;ReadFrame(pBuffer)
</code></pre><hr><h3 id=-input-components-說明>🧩 Input Components 說明</h3><table><thead><tr><th>變數名</th><th>類型 / 來源</th><th>備註</th></tr></thead><tbody><tr><td><code>frameReader</code></td><td><code>unique_ptr&lt;FrameReader></code></td><td>Instance variable（UnCompFrameReader）</td></tr><tr><td><code>SrcBufPool</code></td><td><code>PixMapBufPool</code></td><td>DMA allocator buffer pool</td></tr><tr><td><code>Yuv</code></td><td><code>AL_TBuffer *</code></td><td>使用 <code>SrcYuv.get()</code>（default allocator）</td></tr><tr><td><code>pSrcConv</code></td><td><code>IConvSrc *</code></td><td>若需轉換格式，實體為 <code>CYuvSrcConv</code></td></tr><tr><td><code>firstSink</code></td><td><code>IFrameSink *</code></td><td>encoder sink；<code>enc.get()</code></td></tr><tr><td><code>iPictCount</code></td><td><code>int</code></td><td>frame 計數器</td></tr><tr><td><code>iReadCount</code></td><td><code>int</code></td><td>read 計數器</td></tr></tbody></table><hr><h3 id=-來源建構流程>🏗️ 來源建構流程</h3><ul><li><p><code>frameReader</code><br>→ <code>LayerResources::InitializeFrameReader()</code><br>→ 類型：<code>UnCompFrameReader</code></p></li><li><p><code>pSrcConv</code><br>→ <code>AllocateSrcConverter()</code><br>→ 若格式不同，return <code>make_unique&lt;CYuvSrcConv></code></p></li><li><p><code>SrcYuv</code><br>→ <code>AllocateConversionBuffer(...)</code><br>→ 僅在需要 format conversion 時配置</p></li></ul><hr><h3 id=-read-行為細節>📂 Read 行為細節</h3><ul><li><p><strong>若無需格式轉換</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>frameReader<span style=color:#f92672>-&gt;</span>ReadFrame(pBuffer);
</span></span></code></pre></div></li><li><p><strong>若需格式轉換（例如 I420 → NV12）</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>frameReader<span style=color:#f92672>-&gt;</span>ReadFrame(conversionBuffer);
</span></span><span style=display:flex><span>pSrcConv<span style=color:#f92672>-&gt;</span>ConvertSrcBuf(conversionBuffer, pBuffer);
</span></span></code></pre></div></li></ul><hr><h2 id=fetch-es-output-機制修正2025-07-30>Fetch ES Output 機制修正（2025-07-30）</h2><p>原本的 callback 實作錯誤，導致 encoder 卡住無法繼續輸出 ES。經查證，必須在 callback return 前 <strong>明確呼叫 <code>AL_Encoder_PutStreamBuffer()</code></strong> 歸還 bitstream buffer，encoder 才能繼續使用該 buffer 進行編碼。</p><h3 id=修正後範例>修正後範例：</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myEndEncoding</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>userParam, AL_TBuffer <span style=color:#f92672>*</span>pStream, AL_TBuffer <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>pSrc, <span style=color:#66d9ef>int</span> iLayerID)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> AL_Buffer_GetData(pStream);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  AL_TPictureMetaData <span style=color:#f92672>*</span>pPicMeta <span style=color:#f92672>=</span> (AL_TPictureMetaData <span style=color:#f92672>*</span>) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_PICTURE);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Picture Type %s %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, PictTypeToString(pPicMeta<span style=color:#f92672>-&gt;</span>eType).c_str(), pPicMeta<span style=color:#f92672>-&gt;</span>bSkipped <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;is skipped&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  AL_TStreamMetaData <span style=color:#f92672>*</span>pStreamMeta <span style=color:#f92672>=</span> (AL_TStreamMetaData <span style=color:#f92672>*</span>) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_STREAM);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint16_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> pStreamMeta<span style=color:#f92672>-&gt;</span>uNumSection; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    AL_TStreamSection section <span style=color:#f92672>=</span> pStreamMeta<span style=color:#f92672>-&gt;</span>pSections[i];
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Section %d: size=%d layer=%d, type=%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>           i, section.uLength, iLayerID, SectionFlagToString(section.eFlags).c_str());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 必須在 callback 中還原 buffer，否則 encoder 會卡住
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>bool</span> bRet <span style=color:#f92672>=</span> AL_Encoder_PutStreamBuffer(__hEnc__, pStream);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>bRet) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;AL_Encoder_PutStreamBuffer must always succeed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=註解>註解</h3><p>這種做法令人費解。一般而言若使用 malloc 分配 buffer，應在呼叫 callback 後在呼叫端 free：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>buf <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>callback</span>(buf);
</span></span><span style=display:flex><span><span style=color:#a6e22e>free</span>(buf);  <span style=color:#75715e>// 呼叫端負責釋放
</span></span></span></code></pre></div><p>但 Allegro SDK 的模式卻是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_TBuffer <span style=color:#f92672>*</span>pStream <span style=color:#f92672>=</span> ...; <span style=color:#75715e>// 由 encoder 填寫完的 bitstream buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>callback(pStream);         <span style=color:#75715e>// callback 內部要歸還 pStream ???
</span></span></span></code></pre></div><p>這種設計不符合 callback 的一般用法邏輯，屬於設計隱晦的 API 行為，需額外註明。</p><hr><h2 id=fetch-es-output-機制總覽2025-07-23>Fetch ES Output 機制總覽（2025-07-23）</h2><p>在使用 <code>AL_Encoder_Process()</code> 將 frame 推入 encoder 後，ES bitstream 並非主動呼叫 API 回傳，而是透過 <strong>callback 機制</strong>觸發推送完成的編碼結果。</p><h3 id=callback-實作範例>Callback 實作範例</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myEndEncoding</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>userParam, AL_TBuffer <span style=color:#f92672>*</span>pStream, AL_TBuffer <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>pSrc, <span style=color:#66d9ef>int</span> iLayerID)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> AL_Buffer_GetData(pStream);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 解析 Picture metadata
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  AL_TPictureMetaData <span style=color:#f92672>*</span>pPicMeta <span style=color:#f92672>=</span> (AL_TPictureMetaData <span style=color:#f92672>*</span>) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_PICTURE);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Picture Type %s %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>         PictTypeToString(pPicMeta<span style=color:#f92672>-&gt;</span>eType).c_str(),
</span></span><span style=display:flex><span>         pPicMeta<span style=color:#f92672>-&gt;</span>bSkipped <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;is skipped&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 解析 Stream metadata
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  AL_TStreamMetaData <span style=color:#f92672>*</span>pStreampMeta <span style=color:#f92672>=</span> (AL_TStreamMetaData <span style=color:#f92672>*</span>) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_STREAM);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;sections = %d / %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pStreampMeta<span style=color:#f92672>-&gt;</span>uNumSection, pStreampMeta<span style=color:#f92672>-&gt;</span>uMaxNumSection);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint16_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> pStreampMeta<span style=color:#f92672>-&gt;</span>uNumSection; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    AL_TStreamSection section <span style=color:#f92672>=</span> pStreampMeta<span style=color:#f92672>-&gt;</span>pSections[i];
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;section %d: size = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, section.uLength);
</span></span><span style=display:flex><span>    hexprint(<span style=color:#e6db74>&#34;XX&#34;</span>, <span style=color:#f92672>&amp;</span>data[section.uOffset], min(section.uLength, <span style=color:#ae81ff>64</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=綁定-callback-到-encoder>綁定 callback 到 encoder</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_CB_EndEncoding endEncodingCb <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .func <span style=color:#f92672>=</span> myEndEncoding,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AL_Encoder_Create(..., endEncodingCb);
</span></span></code></pre></div><ul><li><code>AL_CB_EndEncoding</code> 是 Allegro 定義的 callback 包裝結構。</li><li><code>.func</code> 即為綁定的函式指標。</li></ul><h3 id=補充說明>補充說明</h3><ul><li>Bitstream 實際內容透過 <code>AL_TStreamMetaData</code> 描述，可能包含多個 section。</li><li>每個 section 都由 <code>uOffset</code>（於 AL_Buffer 資料區內的起始位置）與 <code>uLength</code>（長度）組成。</li><li>若要串接封裝（封為 .h265 / .mp4）或分析 bitstream，可直接由此處複製資料。</li></ul><hr><h2 id=attach-metadatabitstream-buffer2025-07-23>Attach MetaData：Bitstream Buffer（2025-07-23）</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;AL_MAX_SECTION=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, AL_MAX_SECTION);
</span></span><span style=display:flex><span>AL_TStreamMetaData <span style=color:#f92672>*</span>pStreamMeta <span style=color:#f92672>=</span> AL_StreamMetaData_Create(AL_MAX_SECTION);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> isOk <span style=color:#f92672>=</span> AL_Buffer_AddMetaData(pBsBuf, (AL_TMetaData <span style=color:#f92672>*</span>) pStreamMeta);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isOk) {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Failed to attach metadata to bitstream buffer</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%d ok!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, __LINE__);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=#al_encoder_putstreambuffer-failed-bitstream-buffer-needs-pmetadata2025-07-17>解決 issue</a></p><hr><h2 id=attach-metadatasource-buffer-yuv-input2025-07-23>Attach MetaData：Source Buffer (YUV Input)（2025-07-23）</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_TDimension tDim <span style=color:#f92672>=</span> { settings.tChParam[<span style=color:#ae81ff>0</span>].uSrcWidth, settings.tChParam[<span style=color:#ae81ff>0</span>].uSrcHeight };
</span></span><span style=display:flex><span>AL_TPlane tYPlane <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .iChunkIdx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  .iOffset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  .iPitch <span style=color:#f92672>=</span> tDim.iWidth,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>AL_TPlane tUVPlane <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .iChunkIdx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  .iOffset <span style=color:#f92672>=</span> tYPlane.iPitch <span style=color:#f92672>*</span> tDim.iHeight,
</span></span><span style=display:flex><span>  .iPitch <span style=color:#f92672>=</span> tYPlane.iPitch
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>AL_TPicFormat tPictFormat <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .eChromaMode <span style=color:#f92672>=</span> AL_CHROMA_4_2_0,
</span></span><span style=display:flex><span>  .eAlphaMode <span style=color:#f92672>=</span> AL_ALPHA_MODE_DISABLED,
</span></span><span style=display:flex><span>  .uBitDepth <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>  .eStorageMode <span style=color:#f92672>=</span> AL_FB_RASTER,
</span></span><span style=display:flex><span>  .ePlaneMode <span style=color:#f92672>=</span> AL_PLANE_MODE_SEMIPLANAR,
</span></span><span style=display:flex><span>  .eComponentOrder <span style=color:#f92672>=</span> AL_COMPONENT_ORDER_YUV,
</span></span><span style=display:flex><span>  .eSamplePackMode <span style=color:#f92672>=</span> AL_SAMPLE_PACK_MODE_BYTE,
</span></span><span style=display:flex><span>  .bCompressed <span style=color:#f92672>=</span> false,
</span></span><span style=display:flex><span>  .bMSB <span style=color:#f92672>=</span> false,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>TFourCC tFourCC <span style=color:#f92672>=</span> AL_GetFourCC(tPictFormat);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AL_TMetaData <span style=color:#f92672>*</span>pPixMapMeta <span style=color:#f92672>=</span> (AL_TMetaData <span style=color:#f92672>*</span>) AL_PixMapMetaData_Create(tDim, tYPlane, tUVPlane, tFourCC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> isOk <span style=color:#f92672>=</span> AL_Buffer_AddMetaData(pYuvBuf, pPixMapMeta);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isOk) {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Failed to attach metadata to source buffer</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%d ok!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, __LINE__);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=al_encoder_putstreambuffer-failed-bitstream-buffer-needs-pmetadata2025-07-17>AL_Encoder_PutStreamBuffer() failed, bitstream buffer needs pMetaData（2025-07-17）</h2><p><strong>錯誤訊息</strong>：</p><pre tabindex=0><code>[/lib_encode/Com_Encoder.c:164] pMetaData
lib_rtos.c:39: Rtos_AssertWithMessage: Assertion `false&#39; failed.
</code></pre><p><strong>原因說明</strong>：</p><ul><li><code>pBsBuf</code> 為 encoder 輸出用的 bitstream buffer，但 <code>AL_TBuffer->pMetaData == NULL</code>。</li><li>encoder 內部需要 metadata 來記錄 output size、NAL info 等，若為 null 會觸發硬性 assert。</li></ul><p><strong>目前狀況</strong>：</p><ul><li>尚未找到正確建立 <code>AL_TBuffer</code> 給 <code>AL_Encoder_PutStreamBuffer()</code> 使用的完整做法。</li><li>計畫進一步深入 trace <code>exe_encoder</code>，確認實際建立與使用的流程。</li><li>此項後續補充更新。</li></ul><hr><h2 id=al_encoder_create-失敗原因非參數錯誤而是-allocator-錯用2025-07-17><code>AL_Encoder_Create()</code> 失敗原因非參數錯誤，而是 allocator 錯用（2025-07-17）</h2><p><strong>原先假設</strong>：<code>AL_TEncSettings</code> 設定有誤，與 <code>exe_encoder</code> 對齊後仍失敗。
<strong>真正原因</strong>：使用了錯誤的 allocator。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_TAllocator <span style=color:#f92672>*</span>pAllocator <span style=color:#f92672>=</span> AL_GetDefaultAllocator(); <span style=color:#75715e>// ❌ 僅為 malloc()，非 DMA
</span></span></span></code></pre></div><p><strong>分析</strong>：</p><ul><li>該 allocator 分配的是 host heap memory，硬體無法 DMA 存取。</li><li><code>AL_Encoder_Create()</code> 在檢查 input/output buffer 是否 DMA buffer 時觸發錯誤: (al5e a0200000.al5e: VCU: unavailable resources or wrong configuration)。</li></ul><p><strong>正確做法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_TAllocator <span style=color:#f92672>*</span>pAllocator <span style=color:#f92672>=</span> AL_DmaAlloc_Create(<span style=color:#e6db74>&#34;/dev/allegroIP&#34;</span>); <span style=color:#75715e>// ✅
</span></span></span></code></pre></div><ul><li>該函式透過 driver 分配 DMA buffer（實體記憶體），並用 <code>mmap()</code> 映射到 host，可安全交由 encoder 使用。</li></ul><hr><h2 id=allegro_min_enc-crash-原因排查完成2025-07-10><code>allegro_min_enc</code> crash 原因排查完成（2025-07-10）</h2><p><strong>錯誤訊息</strong>：</p><pre tabindex=0><code>pSubHrdParam-&gt;bit_rate_value_minus1[0] &lt;= (UINT32_MAX - 1)
allegro_min_enc: Rtos_AssertWithMessage: Assertion `false&#39; failed.
</code></pre><p><strong>推論</strong>：</p><ul><li><code>AL_TEncSettings</code> 結構極度複雜，缺乏參考值與預設組合。</li><li>可能欄位之間衝突，導致 encoder 建立失敗。</li></ul><p><strong>處理方式</strong>：</p><ul><li>暫時跳過 <code>allegro_min_enc</code> 測試。</li><li>改採已確認穩定的 <code>exe_encoder</code> 執行檔進行開發與驗證。</li><li>利用 <code>EncoderSink</code> 及 print debug 技術分析 <code>AL_TEncSettings</code> 正確值。</li></ul><hr><h2 id=使用-exe_encoder-並列印-al_tencsettings2025-07-10>使用 <code>exe_encoder</code> 並列印 <code>AL_TEncSettings</code>（2025-07-10）</h2><ul><li>成功執行 <code>exe_encoder</code>，完成測試 YUV 編碼。</li><li>修改 encoder 主程式，<strong>完整印出 <code>AL_TEncSettings</code> 結構所有欄位</strong>，便於後續程式比對與調參。</li></ul><hr><h2 id=build-正確版本的-vcu-control-swvcu-202512025-07-10>Build 正確版本的 VCU Control SW：<code>VCU 2025.1</code>（2025-07-10）</h2><p><strong>關鍵發現</strong>：
雖然 <code>VCU 2023.1</code> 可編譯，但 encoder 實際運行會 crash。
必須使用 <code>VCU 2025.1</code>，才能穩定進行 encoding。</p><p><strong>編譯步驟</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 設定 cross compile 環境</span>
</span></span><span style=display:flex><span>source ~/VEGA2200/trunk/xilinx_sdk_r5_vega6000/sdk/environment-setup-cortexa72-cortexa53-xilinx-linux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 進入正確版本的 source tree</span>
</span></span><span style=display:flex><span>cd ~/vcu-ctrl-sw-xlnx_rel_v2025.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 編譯</span>
</span></span><span style=display:flex><span>make -j8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 確認輸出檔案型態</span>
</span></span><span style=display:flex><span>file bin/AL_Encoder.exe
</span></span></code></pre></div><p><strong>成果</strong>：</p><ul><li>成功產出 <code>AL_Encoder.exe</code>，可於 ZCU106 正常運行。</li><li>輸出 YUV encode 結果正確，bitrate 符合預期，證實 encoder pipeline 可用。</li></ul><hr></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/vcu>VCU</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex></div><div class=footer-info>2025 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>