<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>VCU 開發進度總結 — 2025-07-25 - Hank Tech Lab</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content='VCU 開發進度總結（截至 2025-07-25） 🧩 Callback 機制總覽 在使用 AL_Encoder_Process() 將 frame 推入 encoder 後，bitstream 並非主動由 API 回傳，而是透過 callback 機制主動推送完成的編碼結果。
✅ Callback 實作範例 void myEndEncoding(void *userParam, AL_TBuffer *pStream, AL_TBuffer const *pSrc, int iLayerID) { uint8_t *data = AL_Buffer_GetData(pStream); // 解析 Picture metadata AL_TPictureMetaData *pPicMeta = (AL_TPictureMetaData *) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_PICTURE); printf("Picture Type %s %s\n", PictTypeToString(pPicMeta->eType).c_str(), pPicMeta->bSkipped ? "is skipped" : ""); // 解析 Stream metadata AL_TStreamMetaData *pStreampMeta = (AL_TStreamMetaData *) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_STREAM); printf("sections = %d / %d\n", pStreampMeta->uNumSection, pStreampMeta->uMaxNumSection); for (uint16_t i = 0; i < pStreampMeta->uNumSection; i++) { AL_TStreamSection section = pStreampMeta->pSections[i]; printf("section %d: size = %d\n", i, section.'><meta property="og:image" content><meta property="og:url" content="https://hanketgithub.github.io/tech/vcu_progress_2025-07-25/"><meta property="og:site_name" content="Hank Tech Lab"><meta property="og:title" content="VCU 開發進度總結 — 2025-07-25"><meta property="og:description" content='VCU 開發進度總結（截至 2025-07-25） 🧩 Callback 機制總覽 在使用 AL_Encoder_Process() 將 frame 推入 encoder 後，bitstream 並非主動由 API 回傳，而是透過 callback 機制主動推送完成的編碼結果。
✅ Callback 實作範例 void myEndEncoding(void *userParam, AL_TBuffer *pStream, AL_TBuffer const *pSrc, int iLayerID) { uint8_t *data = AL_Buffer_GetData(pStream); // 解析 Picture metadata AL_TPictureMetaData *pPicMeta = (AL_TPictureMetaData *) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_PICTURE); printf("Picture Type %s %s\n", PictTypeToString(pPicMeta->eType).c_str(), pPicMeta->bSkipped ? "is skipped" : ""); // 解析 Stream metadata AL_TStreamMetaData *pStreampMeta = (AL_TStreamMetaData *) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_STREAM); printf("sections = %d / %d\n", pStreampMeta->uNumSection, pStreampMeta->uMaxNumSection); for (uint16_t i = 0; i < pStreampMeta->uNumSection; i++) { AL_TStreamSection section = pStreampMeta->pSections[i]; printf("section %d: size = %d\n", i, section.'><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="tech"><meta property="article:published_time" content="2025-07-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-25T00:00:00+00:00"><meta property="article:tag" content="VCU"><meta name=twitter:card content="summary"><meta name=twitter:title content="VCU 開發進度總結 — 2025-07-25"><meta name=twitter:description content='VCU 開發進度總結（截至 2025-07-25） 🧩 Callback 機制總覽 在使用 AL_Encoder_Process() 將 frame 推入 encoder 後，bitstream 並非主動由 API 回傳，而是透過 callback 機制主動推送完成的編碼結果。
✅ Callback 實作範例 void myEndEncoding(void *userParam, AL_TBuffer *pStream, AL_TBuffer const *pSrc, int iLayerID) { uint8_t *data = AL_Buffer_GetData(pStream); // 解析 Picture metadata AL_TPictureMetaData *pPicMeta = (AL_TPictureMetaData *) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_PICTURE); printf("Picture Type %s %s\n", PictTypeToString(pPicMeta->eType).c_str(), pPicMeta->bSkipped ? "is skipped" : ""); // 解析 Stream metadata AL_TStreamMetaData *pStreampMeta = (AL_TStreamMetaData *) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_STREAM); printf("sections = %d / %d\n", pStreampMeta->uNumSection, pStreampMeta->uMaxNumSection); for (uint16_t i = 0; i < pStreampMeta->uNumSection; i++) { AL_TStreamSection section = pStreampMeta->pSections[i]; printf("section %d: size = %d\n", i, section.'><link href=https://hanketgithub.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://hanketgithub.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://hanketgithub.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css disabled><style>@media print{body{font-family:pingfang tc,helvetica neue,sans-serif;font-size:12pt;line-height:1.6;color:#000}table,th,td{border:1px solid #666;border-collapse:collapse}th,td{padding:8px 12px;text-align:left}h1,h2{page-break-before:always}h1:first-of-type,h2:first-of-type{page-break-before:auto}img{max-width:100%;height:auto;page-break-inside:avoid}p{page-break-inside:avoid}a{color:#000;text-decoration:none}}</style></head><body><div class=content><header><div class=main><a href=https://hanketgithub.github.io/>Hank Tech Lab</a></div><nav><a href=/posts/>Posts</a>
| <span id=dark-mode-toggle onclick=toggleTheme()><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#sun"/></svg></span>
<script src=https://hanketgithub.github.io/js/themetoggle.js></script></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>VCU 開發進度總結 — 2025-07-25</h1><div class=meta>Posted on Jul 25, 2025</div></div><section class=body><h1 id=vcu-開發進度總結截至-2025-07-25>VCU 開發進度總結（截至 2025-07-25）</h1><hr><h2 id=-callback-機制總覽>🧩 Callback 機制總覽</h2><p>在使用 <code>AL_Encoder_Process()</code> 將 frame 推入 encoder 後，bitstream 並非主動由 API 回傳，而是透過 <strong>callback 機制</strong>主動推送完成的編碼結果。</p><hr><h2 id=-callback-實作範例>✅ Callback 實作範例</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myEndEncoding</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>userParam, AL_TBuffer <span style=color:#f92672>*</span>pStream, AL_TBuffer <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>pSrc, <span style=color:#66d9ef>int</span> iLayerID)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> AL_Buffer_GetData(pStream);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 解析 Picture metadata
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  AL_TPictureMetaData <span style=color:#f92672>*</span>pPicMeta <span style=color:#f92672>=</span> (AL_TPictureMetaData <span style=color:#f92672>*</span>) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_PICTURE);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Picture Type %s %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>         PictTypeToString(pPicMeta<span style=color:#f92672>-&gt;</span>eType).c_str(),
</span></span><span style=display:flex><span>         pPicMeta<span style=color:#f92672>-&gt;</span>bSkipped <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;is skipped&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 解析 Stream metadata
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  AL_TStreamMetaData <span style=color:#f92672>*</span>pStreampMeta <span style=color:#f92672>=</span> (AL_TStreamMetaData <span style=color:#f92672>*</span>) AL_Buffer_GetMetaData(pStream, AL_META_TYPE_STREAM);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;sections = %d / %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pStreampMeta<span style=color:#f92672>-&gt;</span>uNumSection, pStreampMeta<span style=color:#f92672>-&gt;</span>uMaxNumSection);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint16_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> pStreampMeta<span style=color:#f92672>-&gt;</span>uNumSection; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    AL_TStreamSection section <span style=color:#f92672>=</span> pStreampMeta<span style=color:#f92672>-&gt;</span>pSections[i];
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;section %d: size = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, section.uLength);
</span></span><span style=display:flex><span>    hexprint(<span style=color:#e6db74>&#34;XX&#34;</span>, <span style=color:#f92672>&amp;</span>data[section.uOffset], <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=-綁定-callback-到-encoder>🏗 綁定 callback 到 encoder</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_CB_EndEncoding endEncodingCb <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .func <span style=color:#f92672>=</span> myEndEncoding,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AL_Encoder_Create(..., endEncodingCb);
</span></span></code></pre></div><ul><li><code>AL_CB_EndEncoding</code> 是 Allegro 定義的 callback 包裝結構。</li><li><code>.func</code> 即為綁定的函式指標。</li></ul><hr><h2 id=-補充說明>📦 補充說明</h2><ul><li>Bitstream 實際內容透過 <code>AL_TStreamMetaData</code> 描述，可能包含多個 section。</li><li>每個 section 都由 <code>uOffset</code>（於 AL_Buffer 資料區內的起始位置）與 <code>uLength</code>（長度）組成。</li><li>若要串接封裝（封為 .h265 / .mp4）或分析 bitstream，可直接由此處複製資料。</li></ul><hr><h2 id=-attach-metadatabitstream-buffer>🧷 Attach MetaData：Bitstream Buffer</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;AL_MAX_SECTION=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, AL_MAX_SECTION);
</span></span><span style=display:flex><span>AL_TStreamMetaData <span style=color:#f92672>*</span>pStreamMeta <span style=color:#f92672>=</span> AL_StreamMetaData_Create(AL_MAX_SECTION);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> isOk <span style=color:#f92672>=</span> AL_Buffer_AddMetaData(pBsBuf, (AL_TMetaData <span style=color:#f92672>*</span>) pStreamMeta);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isOk) {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Failed to attach metadata to bitstream buffer</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%d ok!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, __LINE__);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=-attach-metadatasource-buffer-yuv-input>🧷 Attach MetaData：Source Buffer (YUV Input)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_TDimension tDim <span style=color:#f92672>=</span> { settings.tChParam[<span style=color:#ae81ff>0</span>].uSrcWidth, settings.tChParam[<span style=color:#ae81ff>0</span>].uSrcHeight };
</span></span><span style=display:flex><span>AL_TPlane tYPlane <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .iChunkIdx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  .iOffset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  .iPitch <span style=color:#f92672>=</span> tDim.iWidth,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>AL_TPlane tUVPlane <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .iChunkIdx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  .iOffset <span style=color:#f92672>=</span> tYPlane.iPitch <span style=color:#f92672>*</span> tDim.iHeight,
</span></span><span style=display:flex><span>  .iPitch <span style=color:#f92672>=</span> tYPlane.iPitch
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>AL_TPicFormat tPictFormat <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .eChromaMode <span style=color:#f92672>=</span> AL_CHROMA_4_2_0,
</span></span><span style=display:flex><span>  .eAlphaMode <span style=color:#f92672>=</span> AL_ALPHA_MODE_DISABLED,
</span></span><span style=display:flex><span>  .uBitDepth <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>  .eStorageMode <span style=color:#f92672>=</span> AL_FB_RASTER,
</span></span><span style=display:flex><span>  .ePlaneMode <span style=color:#f92672>=</span> AL_PLANE_MODE_SEMIPLANAR,
</span></span><span style=display:flex><span>  .eComponentOrder <span style=color:#f92672>=</span> AL_COMPONENT_ORDER_YUV,
</span></span><span style=display:flex><span>  .eSamplePackMode <span style=color:#f92672>=</span> AL_SAMPLE_PACK_MODE_BYTE,
</span></span><span style=display:flex><span>  .bCompressed <span style=color:#f92672>=</span> false,
</span></span><span style=display:flex><span>  .bMSB <span style=color:#f92672>=</span> false,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>TFourCC tFourCC <span style=color:#f92672>=</span> AL_GetFourCC(tPictFormat);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AL_TMetaData <span style=color:#f92672>*</span>pPixMapMeta <span style=color:#f92672>=</span> (AL_TMetaData <span style=color:#f92672>*</span>) AL_PixMapMetaData_Create(tDim, tYPlane, tUVPlane, tFourCC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> isOk <span style=color:#f92672>=</span> AL_Buffer_AddMetaData(pYuvBuf, pPixMapMeta);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isOk) {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Failed to attach metadata to source buffer</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%d ok!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, __LINE__);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>✅ <strong>此機制已成功驗證，建議納入 encoding pipeline 的後處理模組。</strong></p><hr><h2 id=-1-al_encoder_putstreambuffer-失敗bitstream-buffer-缺少-pmetadata2025-07-17>✅ 1. <code>AL_Encoder_PutStreamBuffer()</code> 失敗，bitstream buffer 缺少 pMetaData（2025-07-17）</h2><ul><li><p><strong>錯誤訊息</strong>：</p><pre tabindex=0><code>[/lib_encode/Com_Encoder.c:164] pMetaData
lib_rtos.c:39: Rtos_AssertWithMessage: Assertion `false&#39; failed.
</code></pre></li><li><p><strong>原因說明</strong>：</p><ul><li><code>pBsBuf</code> 為 encoder 輸出用的 bitstream buffer，但 <code>AL_TBuffer->pMetaData == NULL</code>。</li><li>encoder 內部需要 metadata 來記錄 output size、NAL info 等，若為 null 會觸發硬性 assert。</li></ul></li><li><p><strong>目前狀況</strong>：</p><ul><li>尚未找到正確建立 <code>AL_TBuffer</code> 給 <code>AL_Encoder_PutStreamBuffer()</code> 使用的完整做法。</li><li>計畫進一步深入 trace <code>exe_encoder</code>，確認實際建立與使用的流程。</li><li>此項後續補充更新。</li></ul></li></ul><hr><h2 id=-2-al_encoder_create-失敗原因非參數錯誤而是-allocator-錯用2025-07-17>✅ 2. <code>AL_Encoder_Create()</code> 失敗原因非參數錯誤，而是 allocator 錯用（2025-07-17）</h2><ul><li><p><strong>原先假設</strong>：<code>AL_TEncSettings</code> 設定有誤，與 <code>exe_encoder</code> 對齊後仍失敗。</p></li><li><p><strong>真正原因</strong>：使用了錯誤的 allocator。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_TAllocator<span style=color:#f92672>*</span> pAllocator <span style=color:#f92672>=</span> AL_GetDefaultAllocator(); <span style=color:#75715e>// ❌ 僅為 malloc()，非 DMA
</span></span></span></code></pre></div></li><li><p><strong>分析</strong>：</p><ul><li>該 allocator 分配的是 host heap memory，硬體無法 DMA 存取。</li><li><code>AL_Encoder_Create()</code> 在檢查 input/output buffer 是否 DMA buffer 時觸發錯誤: (al5e a0200000.al5e: VCU: unavailable resources or wrong configuration)。</li></ul></li><li><p><strong>正確做法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AL_TAllocator<span style=color:#f92672>*</span> pAllocator <span style=color:#f92672>=</span> AL_DmaAlloc_Create(<span style=color:#e6db74>&#34;/dev/allegroIP&#34;</span>); <span style=color:#75715e>// ✅
</span></span></span></code></pre></div><ul><li>該函式透過 driver 分配 DMA buffer（實體記憶體），並用 <code>mmap()</code> 映射到 host，可安全交由 encoder 使用。</li></ul></li></ul><hr><h2 id=-3-allegro_min_enc-crash-原因排查完成2025-07-10>✅ 3. <code>allegro_min_enc</code> crash 原因排查完成（2025-07-10）</h2><ul><li><p><strong>錯誤訊息</strong>：</p><pre tabindex=0><code>pSubHrdParam-&gt;bit_rate_value_minus1[0] &lt;= (UINT32_MAX - 1)
allegro_min_enc: Rtos_AssertWithMessage: Assertion `false&#39; failed.
</code></pre></li><li><p><strong>推論</strong>：</p><ul><li><code>AL_TEncSettings</code> 結構極度複雜，缺乏參考值與預設組合。</li><li>可能欄位之間衝突，導致 encoder 建立失敗。</li></ul></li><li><p><strong>處理方式</strong>：</p><ul><li>暫時跳過 <code>allegro_min_enc</code> 測試。</li><li>改採已確認穩定的 <code>exe_encoder</code> 執行檔進行開發與驗證。</li><li>利用 <code>EncoderSink</code> 及 print debug 技術分析 <code>AL_TEncSettings</code> 正確值。</li></ul></li></ul><hr><h2 id=-4-使用-exe_encoder-並列印-al_tencsettings2025-07-10>✅ 4. 使用 <code>exe_encoder</code> 並列印 <code>AL_TEncSettings</code>（2025-07-10）</h2><ul><li>成功執行 <code>exe_encoder</code>，完成測試 YUV 編碼。</li><li>修改 encoder 主程式，<strong>完整印出 <code>AL_TEncSettings</code> 結構所有欄位</strong>，便於後續程式比對與調參。</li></ul><hr><h2 id=-5-build-正確版本的-vcu-control-swvcu-202512025-07-10>✅ 5. Build 正確版本的 VCU Control SW：<code>VCU 2025.1</code>（2025-07-10）</h2><ul><li><p><strong>關鍵發現</strong>：</p><ul><li>雖然 <code>VCU 2023.1</code> 可編譯，但 encoder 實際運行會 crash。</li><li>必須使用 <code>VCU 2025.1</code>，才能穩定進行 encoding。</li></ul></li><li><p><strong>編譯步驟</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 設定 cross compile 環境</span>
</span></span><span style=display:flex><span>source ~/VEGA2200/trunk/xilinx_sdk_r5_vega6000/sdk/environment-setup-cortexa72-cortexa53-xilinx-linux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 進入正確版本的 source tree</span>
</span></span><span style=display:flex><span>cd ~/vcu-ctrl-sw-xlnx_rel_v2025.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 編譯</span>
</span></span><span style=display:flex><span>make -j8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 確認輸出檔案型態</span>
</span></span><span style=display:flex><span>file bin/AL_Encoder.exe
</span></span></code></pre></div></li><li><p><strong>成果</strong>：</p><ul><li>成功產出 <code>AL_Encoder.exe</code>，可於 ZCU106 正常運行。</li><li>輸出 YUV encode 結果正確，bitrate 符合預期，證實 encoder pipeline 可用。</li></ul></li></ul><hr></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/vcu>VCU</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex></div><div class=footer-info>2025 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>